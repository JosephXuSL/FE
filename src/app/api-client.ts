/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:5001';
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCourses(body: CourseRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCourses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCourses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCourses(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCourses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCourses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCourses(body: CourseRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateCourses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCourses(): Observable<Course[]> {
        let url_ = this.baseUrl + "/GetAllCourses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourses(<any>response_);
                } catch (e) {
                    return <Observable<Course[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Course[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCourses(response: HttpResponseBase): Observable<Course[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Course.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Course[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCoursesByIds(body: number[] | null | undefined): Observable<Course[]> {
        let url_ = this.baseUrl + "/GetCoursesByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoursesByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoursesByIds(<any>response_);
                } catch (e) {
                    return <Observable<Course[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Course[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoursesByIds(response: HttpResponseBase): Observable<Course[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Course.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Course[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTeachers(body: TeacherRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddTeachers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTeachers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTeachers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddTeachers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTeachers(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveTeachers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTeachers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTeachers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTeachers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTeachers(body: TeacherRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateTeachers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTeachers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeachers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTeachers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTeachers(): Observable<Teacher[]> {
        let url_ = this.baseUrl + "/GetAllTeachers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeachers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeachers(<any>response_);
                } catch (e) {
                    return <Observable<Teacher[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Teacher[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeachers(response: HttpResponseBase): Observable<Teacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Teacher.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Teacher[]>(<any>null);
    }

    /**
     * @return Success
     */
    findTeachersByName(name: string | null): Observable<Teacher[]> {
        let url_ = this.baseUrl + "/FindTeachersByName/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindTeachersByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindTeachersByName(<any>response_);
                } catch (e) {
                    return <Observable<Teacher[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Teacher[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindTeachersByName(response: HttpResponseBase): Observable<Teacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Teacher.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Teacher[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getTeacherByIds(body: number[] | null | undefined): Observable<Teacher[]> {
        let url_ = this.baseUrl + "/GetTeacherByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherByIds(<any>response_);
                } catch (e) {
                    return <Observable<Teacher[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Teacher[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeacherByIds(response: HttpResponseBase): Observable<Teacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Teacher.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Teacher[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addMajors(body: MajorRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddMajors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMajors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMajors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMajors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeMajors(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveMajors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveMajors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveMajors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveMajors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMajors(body: MajorRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateMajors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMajors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMajors(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMajors(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMajors(): Observable<Major[]> {
        let url_ = this.baseUrl + "/GetAllMajors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMajors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMajors(<any>response_);
                } catch (e) {
                    return <Observable<Major[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Major[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMajors(response: HttpResponseBase): Observable<Major[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Major.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Major[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartmentByGrade(grade: string | null): Observable<string[]> {
        let url_ = this.baseUrl + "/GetDepartmentByGrade/{grade}";
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentByGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentByGrade(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentByGrade(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param grade (optional) 
     * @param department (optional) 
     * @return Success
     */
    getMajorNameByGradeAndDepartment(grade: string | null | undefined, department: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/GetMajorNameByGradeAndDepartment?";
        if (grade !== undefined && grade !== null)
            url_ += "grade=" + encodeURIComponent("" + grade) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMajorNameByGradeAndDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMajorNameByGradeAndDepartment(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMajorNameByGradeAndDepartment(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMajors(body: GetMajorRequestBody | undefined): Observable<Major[]> {
        let url_ = this.baseUrl + "/GetMajors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMajors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMajors(<any>response_);
                } catch (e) {
                    return <Observable<Major[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Major[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMajors(response: HttpResponseBase): Observable<Major[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Major.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Major[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMajorByIds(body: number[] | null | undefined): Observable<Major[]> {
        let url_ = this.baseUrl + "/GetMajorByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMajorByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMajorByIds(<any>response_);
                } catch (e) {
                    return <Observable<Major[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Major[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMajorByIds(response: HttpResponseBase): Observable<Major[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Major.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Major[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTeacherReceivedAward(body: TeacherReceivedAwardRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddTeacherReceivedAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTeacherReceivedAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTeacherReceivedAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddTeacherReceivedAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTeacherReceivedAward(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveTeacherReceivedAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTeacherReceivedAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTeacherReceivedAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTeacherReceivedAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTeacherReceivedAward(body: TeacherReceivedAwardRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateTeacherReceivedAward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTeacherReceivedAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeacherReceivedAward(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTeacherReceivedAward(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTeacherReceivedAward(): Observable<TeacherReceivedAward[]> {
        let url_ = this.baseUrl + "/GetAllTeacherReceivedAward";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeacherReceivedAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeacherReceivedAward(<any>response_);
                } catch (e) {
                    return <Observable<TeacherReceivedAward[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeacherReceivedAward[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeacherReceivedAward(response: HttpResponseBase): Observable<TeacherReceivedAward[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeacherReceivedAward.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherReceivedAward[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTeacherReceivedAwardByTeacherId(id: number): Observable<TeacherReceivedAward[]> {
        let url_ = this.baseUrl + "/GetTeacherReceivedAwardByTeacherId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherReceivedAwardByTeacherId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherReceivedAwardByTeacherId(<any>response_);
                } catch (e) {
                    return <Observable<TeacherReceivedAward[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeacherReceivedAward[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeacherReceivedAwardByTeacherId(response: HttpResponseBase): Observable<TeacherReceivedAward[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeacherReceivedAward.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherReceivedAward[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTeacherAccounts(body: TeacherAccountRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddTeacherAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTeacherAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTeacherAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddTeacherAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTeacherAccounts(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveTeacherAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTeacherAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTeacherAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTeacherAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTeacherAccounts(body: TeacherAccountRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateTeacherAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTeacherAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeacherAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTeacherAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTeacherAccounts(): Observable<TeacherAccount[]> {
        let url_ = this.baseUrl + "/GetAllTeacherAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeacherAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeacherAccounts(<any>response_);
                } catch (e) {
                    return <Observable<TeacherAccount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeacherAccount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeacherAccounts(response: HttpResponseBase): Observable<TeacherAccount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeacherAccount.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherAccount[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTeacherAccountByTeacherId(id: number): Observable<TeacherAccount> {
        let url_ = this.baseUrl + "/GetTeacherAccountByTeacherId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherAccountByTeacherId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherAccountByTeacherId(<any>response_);
                } catch (e) {
                    return <Observable<TeacherAccount>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeacherAccount>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeacherAccountByTeacherId(response: HttpResponseBase): Observable<TeacherAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherAccount>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClasses(body: ClassRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddClasses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClasses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddClasses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeClasses(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveClasses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveClasses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveClasses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClasses(body: ClassRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateClasses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClasses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClasses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllClasses(): Observable<Class[]> {
        let url_ = this.baseUrl + "/GetAllClasses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClasses(<any>response_);
                } catch (e) {
                    return <Observable<Class[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Class[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClasses(response: HttpResponseBase): Observable<Class[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Class.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Class[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClassesByIds(body: number[] | null | undefined): Observable<Class[]> {
        let url_ = this.baseUrl + "/GetClassesByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassesByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassesByIds(<any>response_);
                } catch (e) {
                    return <Observable<Class[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Class[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassesByIds(response: HttpResponseBase): Observable<Class[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Class.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Class[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClassesByMajorIds(body: number[] | null | undefined): Observable<Class[]> {
        let url_ = this.baseUrl + "/GetClassesByMajorIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassesByMajorIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassesByMajorIds(<any>response_);
                } catch (e) {
                    return <Observable<Class[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Class[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassesByMajorIds(response: HttpResponseBase): Observable<Class[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Class.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Class[]>(<any>null);
    }

    /**
     * @return Success
     */
    getClassesByMentorId(id: number): Observable<Class[]> {
        let url_ = this.baseUrl + "/GetClassesByMentorId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassesByMentorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassesByMentorId(<any>response_);
                } catch (e) {
                    return <Observable<Class[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Class[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassesByMentorId(response: HttpResponseBase): Observable<Class[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Class.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Class[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClassesByClassInfo(body: ClassInfoRequestBody | undefined): Observable<Class[]> {
        let url_ = this.baseUrl + "/GetClassesByClassInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassesByClassInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassesByClassInfo(<any>response_);
                } catch (e) {
                    return <Observable<Class[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Class[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassesByClassInfo(response: HttpResponseBase): Observable<Class[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Class.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Class[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addStudents(body: StudentRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddStudents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStudents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStudents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddStudents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeStudents(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveStudents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveStudents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveStudents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveStudents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStudents(body: StudentRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateStudents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStudents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStudents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStudents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllStudents(): Observable<Student[]> {
        let url_ = this.baseUrl + "/GetAllStudents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStudents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStudents(<any>response_);
                } catch (e) {
                    return <Observable<Student[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStudents(response: HttpResponseBase): Observable<Student[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Student.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStudentsByName(name: string | null): Observable<Student[]> {
        let url_ = this.baseUrl + "/GetStudentsByName/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentsByName(<any>response_);
                } catch (e) {
                    return <Observable<Student[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStudentsByName(response: HttpResponseBase): Observable<Student[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Student.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStudentByIDCardNumber(number: string | null): Observable<Student> {
        let url_ = this.baseUrl + "/GetStudentByIDCardNumber/{number}";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentByIDCardNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentByIDCardNumber(<any>response_);
                } catch (e) {
                    return <Observable<Student>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student>><any>_observableThrow(response_);
        }));
    }

    protected processGetStudentByIDCardNumber(response: HttpResponseBase): Observable<Student> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Student.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStudentsByClassInfo(body: ClassInfoRequestBody | undefined): Observable<Student[]> {
        let url_ = this.baseUrl + "/GetStudentsByClassInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentsByClassInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentsByClassInfo(<any>response_);
                } catch (e) {
                    return <Observable<Student[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStudentsByClassInfo(response: HttpResponseBase): Observable<Student[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Student.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStudentsByIds(body: number[] | null | undefined): Observable<Student[]> {
        let url_ = this.baseUrl + "/GetStudentsByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentsByIds(<any>response_);
                } catch (e) {
                    return <Observable<Student[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStudentsByIds(response: HttpResponseBase): Observable<Student[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Student.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addEnroll(body: EnrollRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddEnroll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEnroll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEnroll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddEnroll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeEnroll(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveEnroll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEnroll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEnroll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEnroll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEnroll(body: EnrollRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateEnroll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEnroll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEnroll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEnroll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEnroll(): Observable<Enroll[]> {
        let url_ = this.baseUrl + "/GetAllEnroll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEnroll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEnroll(<any>response_);
                } catch (e) {
                    return <Observable<Enroll[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enroll[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEnroll(response: HttpResponseBase): Observable<Enroll[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enroll.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enroll[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getEnrollByMajor(body: GetMajorRequestBody | undefined): Observable<Enroll[]> {
        let url_ = this.baseUrl + "/GetEnrollByMajor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnrollByMajor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnrollByMajor(<any>response_);
                } catch (e) {
                    return <Observable<Enroll[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Enroll[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnrollByMajor(response: HttpResponseBase): Observable<Enroll[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Enroll.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Enroll[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEnrollByIDCardNumber(number: string | null): Observable<Student> {
        let url_ = this.baseUrl + "/GetEnrollByIDCardNumber/{number}";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnrollByIDCardNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnrollByIDCardNumber(<any>response_);
                } catch (e) {
                    return <Observable<Student>><any>_observableThrow(e);
                }
            } else
                return <Observable<Student>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnrollByIDCardNumber(response: HttpResponseBase): Observable<Student> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Student.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Student>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCourseResponsibleByTeacher(body: CourseResponsibleByTeacherRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddCourseResponsibleByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCourseResponsibleByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCourseResponsibleByTeacher(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCourseResponsibleByTeacher(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCourseResponsibleByTeacher(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveCourseResponsibleByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCourseResponsibleByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCourseResponsibleByTeacher(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCourseResponsibleByTeacher(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCourseResponsibleByTeacher(body: CourseResponsibleByTeacherRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateCourseResponsibleByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourseResponsibleByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourseResponsibleByTeacher(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourseResponsibleByTeacher(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCourseResponsibleByTeacher(): Observable<CourseResponsibleByTeacher[]> {
        let url_ = this.baseUrl + "/GetAllCourseResponsibleByTeacher";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourseResponsibleByTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourseResponsibleByTeacher(<any>response_);
                } catch (e) {
                    return <Observable<CourseResponsibleByTeacher[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseResponsibleByTeacher[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCourseResponsibleByTeacher(response: HttpResponseBase): Observable<CourseResponsibleByTeacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseResponsibleByTeacher.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponsibleByTeacher[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseAndClassByTeacherId(id: number): Observable<CourseResponsibleByTeacher[]> {
        let url_ = this.baseUrl + "/GetCourseAndClassByTeacherId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseAndClassByTeacherId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseAndClassByTeacherId(<any>response_);
                } catch (e) {
                    return <Observable<CourseResponsibleByTeacher[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseResponsibleByTeacher[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourseAndClassByTeacherId(response: HttpResponseBase): Observable<CourseResponsibleByTeacher[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseResponsibleByTeacher.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponsibleByTeacher[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCourseSchedule(body: CourseScheduleRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddCourseSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCourseSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCourseSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCourseSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCourseSchedule(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveCourseSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCourseSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCourseSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCourseSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCourseSchedule(body: CourseScheduleRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateCourseSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourseSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourseSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourseSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCourseSchedule(): Observable<CourseSchedule[]> {
        let url_ = this.baseUrl + "/GetAllCourseSchedule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourseSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourseSchedule(<any>response_);
                } catch (e) {
                    return <Observable<CourseSchedule[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseSchedule[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCourseSchedule(response: HttpResponseBase): Observable<CourseSchedule[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseSchedule.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseSchedule[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseScheduleByTeacherId(teacherId: number): Observable<CourseSchedule[]> {
        let url_ = this.baseUrl + "/GetCourseScheduleByTeacherId/{teacherId}";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined.");
        url_ = url_.replace("{teacherId}", encodeURIComponent("" + teacherId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseScheduleByTeacherId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseScheduleByTeacherId(<any>response_);
                } catch (e) {
                    return <Observable<CourseSchedule[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseSchedule[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourseScheduleByTeacherId(response: HttpResponseBase): Observable<CourseSchedule[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseSchedule.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseSchedule[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseScheduleByClassId(classId: number): Observable<CourseSchedule[]> {
        let url_ = this.baseUrl + "/GetCourseScheduleByClassId/{classId}";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined.");
        url_ = url_.replace("{classId}", encodeURIComponent("" + classId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseScheduleByClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseScheduleByClassId(<any>response_);
                } catch (e) {
                    return <Observable<CourseSchedule[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseSchedule[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourseScheduleByClassId(response: HttpResponseBase): Observable<CourseSchedule[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseSchedule.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseSchedule[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCourseSelection(body: CourseSelectionRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddCourseSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCourseSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCourseSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCourseSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeCourseSelection(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveCourseSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCourseSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCourseSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCourseSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCourseSelection(body: CourseSelectionRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateCourseSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCourseSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCourseSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCourseSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCourseSelection(): Observable<CourseSelection[]> {
        let url_ = this.baseUrl + "/GetAllCourseSelection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourseSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourseSelection(<any>response_);
                } catch (e) {
                    return <Observable<CourseSelection[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseSelection[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCourseSelection(response: HttpResponseBase): Observable<CourseSelection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseSelection.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseSelection[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCourseSelectionByStudentId(studentId: number): Observable<CourseSelection[]> {
        let url_ = this.baseUrl + "/GetCourseSelectionByStudentId/{studentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{studentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseSelectionByStudentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseSelectionByStudentId(<any>response_);
                } catch (e) {
                    return <Observable<CourseSelection[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseSelection[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourseSelectionByStudentId(response: HttpResponseBase): Observable<CourseSelection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseSelection.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseSelection[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addExaminations(body: ExaminationRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AddExaminations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExaminations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExaminations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddExaminations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeExaminations(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/RemoveExaminations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveExaminations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveExaminations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveExaminations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateExaminations(body: ExaminationRequestBody[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UpdateExaminations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExaminations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExaminations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExaminations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllExaminations(): Observable<Examination[]> {
        let url_ = this.baseUrl + "/GetAllExaminations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExaminations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExaminations(<any>response_);
                } catch (e) {
                    return <Observable<Examination[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Examination[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExaminations(response: HttpResponseBase): Observable<Examination[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Examination.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Examination[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getExaminationsByStudentIds(body: number[] | null | undefined): Observable<Examination[]> {
        let url_ = this.baseUrl + "/GetExaminationsByStudentIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExaminationsByStudentIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExaminationsByStudentIds(<any>response_);
                } catch (e) {
                    return <Observable<Examination[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Examination[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExaminationsByStudentIds(response: HttpResponseBase): Observable<Examination[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Examination.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Examination[]>(<any>null);
    }

    /**
     * @param teacherName (optional) 
     * @param password (optional) 
     * @return Success
     */
    getTeacherAccountByTeacherNameAndPassword(teacherName: string | null | undefined, password: string | null | undefined, details: string): Observable<TeacherAccount> {
        let url_ = this.baseUrl + "/GetTeacherAccountByTeacherNameAndPassword/{details}?";
        if (details === undefined || details === null)
            throw new Error("The parameter 'details' must be defined.");
        url_ = url_.replace("{details}", encodeURIComponent("" + details));
        if (teacherName !== undefined && teacherName !== null)
            url_ += "teacherName=" + encodeURIComponent("" + teacherName) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTeacherAccountByTeacherNameAndPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTeacherAccountByTeacherNameAndPassword(<any>response_);
                } catch (e) {
                    return <Observable<TeacherAccount>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeacherAccount>><any>_observableThrow(response_);
        }));
    }

    protected processGetTeacherAccountByTeacherNameAndPassword(response: HttpResponseBase): Observable<TeacherAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeacherAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeacherAccount>(<any>null);
    }
}

export class CourseRequestBody implements ICourseRequestBody {
    id!: number;
    courseName!: string;
    textbook?: string | undefined;

    constructor(data?: ICourseRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseName = _data["courseName"];
            this.textbook = _data["textbook"];
        }
    }

    static fromJS(data: any): CourseRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new CourseRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseName"] = this.courseName;
        data["textbook"] = this.textbook;
        return data; 
    }
}

export interface ICourseRequestBody {
    id: number;
    courseName: string;
    textbook?: string | undefined;
}

export class Course implements ICourse {
    id?: number;
    courseName?: string | undefined;
    textbook?: string | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseName = _data["courseName"];
            this.textbook = _data["textbook"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseName"] = this.courseName;
        data["textbook"] = this.textbook;
        return data; 
    }
}

export interface ICourse {
    id?: number;
    courseName?: string | undefined;
    textbook?: string | undefined;
}

export class TeacherRequestBody implements ITeacherRequestBody {
    id!: number;
    name!: string;
    teacherNumber!: string;
    teacherStatus?: string | undefined;
    teacherComment?: string | undefined;
    phoneNumber?: string | undefined;
    isMentor?: boolean;

    constructor(data?: ITeacherRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.teacherNumber = _data["teacherNumber"];
            this.teacherStatus = _data["teacherStatus"];
            this.teacherComment = _data["teacherComment"];
            this.phoneNumber = _data["phoneNumber"];
            this.isMentor = _data["isMentor"];
        }
    }

    static fromJS(data: any): TeacherRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["teacherNumber"] = this.teacherNumber;
        data["teacherStatus"] = this.teacherStatus;
        data["teacherComment"] = this.teacherComment;
        data["phoneNumber"] = this.phoneNumber;
        data["isMentor"] = this.isMentor;
        return data; 
    }
}

export interface ITeacherRequestBody {
    id: number;
    name: string;
    teacherNumber: string;
    teacherStatus?: string | undefined;
    teacherComment?: string | undefined;
    phoneNumber?: string | undefined;
    isMentor?: boolean;
}

export class Teacher implements ITeacher {
    id?: number;
    name?: string | undefined;
    teacherNumber?: string | undefined;
    teacherStatus?: string | undefined;
    teacherComment?: string | undefined;
    phoneNumber?: string | undefined;
    isMentor?: boolean;

    constructor(data?: ITeacher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.teacherNumber = _data["teacherNumber"];
            this.teacherStatus = _data["teacherStatus"];
            this.teacherComment = _data["teacherComment"];
            this.phoneNumber = _data["phoneNumber"];
            this.isMentor = _data["isMentor"];
        }
    }

    static fromJS(data: any): Teacher {
        data = typeof data === 'object' ? data : {};
        let result = new Teacher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["teacherNumber"] = this.teacherNumber;
        data["teacherStatus"] = this.teacherStatus;
        data["teacherComment"] = this.teacherComment;
        data["phoneNumber"] = this.phoneNumber;
        data["isMentor"] = this.isMentor;
        return data; 
    }
}

export interface ITeacher {
    id?: number;
    name?: string | undefined;
    teacherNumber?: string | undefined;
    teacherStatus?: string | undefined;
    teacherComment?: string | undefined;
    phoneNumber?: string | undefined;
    isMentor?: boolean;
}

export class MajorRequestBody implements IMajorRequestBody {
    id!: number;
    department!: string;
    grade!: string;
    majorName!: string;

    constructor(data?: IMajorRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.department = _data["department"];
            this.grade = _data["grade"];
            this.majorName = _data["majorName"];
        }
    }

    static fromJS(data: any): MajorRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new MajorRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["department"] = this.department;
        data["grade"] = this.grade;
        data["majorName"] = this.majorName;
        return data; 
    }
}

export interface IMajorRequestBody {
    id: number;
    department: string;
    grade: string;
    majorName: string;
}

export class Major implements IMajor {
    id?: number;
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;

    constructor(data?: IMajor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.department = _data["department"];
            this.grade = _data["grade"];
            this.majorName = _data["majorName"];
        }
    }

    static fromJS(data: any): Major {
        data = typeof data === 'object' ? data : {};
        let result = new Major();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["department"] = this.department;
        data["grade"] = this.grade;
        data["majorName"] = this.majorName;
        return data; 
    }
}

export interface IMajor {
    id?: number;
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;
}

export class GetMajorRequestBody implements IGetMajorRequestBody {
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;

    constructor(data?: IGetMajorRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.department = _data["department"];
            this.grade = _data["grade"];
            this.majorName = _data["majorName"];
        }
    }

    static fromJS(data: any): GetMajorRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetMajorRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["department"] = this.department;
        data["grade"] = this.grade;
        data["majorName"] = this.majorName;
        return data; 
    }
}

export interface IGetMajorRequestBody {
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;
}

export class TeacherReceivedAwardRequestBody implements ITeacherReceivedAwardRequestBody {
    id!: number;
    awardName!: string;
    awardDate!: Date;
    detail?: string | undefined;
    teacherId!: number;

    constructor(data?: ITeacherReceivedAwardRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.awardName = _data["awardName"];
            this.awardDate = _data["awardDate"] ? new Date(_data["awardDate"].toString()) : <any>undefined;
            this.detail = _data["detail"];
            this.teacherId = _data["teacherId"];
        }
    }

    static fromJS(data: any): TeacherReceivedAwardRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherReceivedAwardRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["awardName"] = this.awardName;
        data["awardDate"] = this.awardDate ? this.awardDate.toISOString() : <any>undefined;
        data["detail"] = this.detail;
        data["teacherId"] = this.teacherId;
        return data; 
    }
}

export interface ITeacherReceivedAwardRequestBody {
    id: number;
    awardName: string;
    awardDate: Date;
    detail?: string | undefined;
    teacherId: number;
}

export class TeacherReceivedAward implements ITeacherReceivedAward {
    id?: number;
    awardName?: string | undefined;
    awardDate?: Date;
    detail?: string | undefined;
    teacherId?: number;
    teacher?: Teacher;

    constructor(data?: ITeacherReceivedAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.awardName = _data["awardName"];
            this.awardDate = _data["awardDate"] ? new Date(_data["awardDate"].toString()) : <any>undefined;
            this.detail = _data["detail"];
            this.teacherId = _data["teacherId"];
            this.teacher = _data["teacher"] ? Teacher.fromJS(_data["teacher"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeacherReceivedAward {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherReceivedAward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["awardName"] = this.awardName;
        data["awardDate"] = this.awardDate ? this.awardDate.toISOString() : <any>undefined;
        data["detail"] = this.detail;
        data["teacherId"] = this.teacherId;
        data["teacher"] = this.teacher ? this.teacher.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITeacherReceivedAward {
    id?: number;
    awardName?: string | undefined;
    awardDate?: Date;
    detail?: string | undefined;
    teacherId?: number;
    teacher?: Teacher;
}

export class TeacherAccountRequestBody implements ITeacherAccountRequestBody {
    id!: number;
    teacherId!: number;
    accountName!: string;
    password!: string;
    accountStatus?: string | undefined;
    isMentorAccount!: boolean;

    constructor(data?: ITeacherAccountRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teacherId = _data["teacherId"];
            this.accountName = _data["accountName"];
            this.password = _data["password"];
            this.accountStatus = _data["accountStatus"];
            this.isMentorAccount = _data["isMentorAccount"];
        }
    }

    static fromJS(data: any): TeacherAccountRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAccountRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teacherId"] = this.teacherId;
        data["accountName"] = this.accountName;
        data["password"] = this.password;
        data["accountStatus"] = this.accountStatus;
        data["isMentorAccount"] = this.isMentorAccount;
        return data; 
    }
}

export interface ITeacherAccountRequestBody {
    id: number;
    teacherId: number;
    accountName: string;
    password: string;
    accountStatus?: string | undefined;
    isMentorAccount: boolean;
}

export class TeacherAccount implements ITeacherAccount {
    id?: number;
    teacherId?: number;
    teacher?: Teacher;
    accountName?: string | undefined;
    password?: string | undefined;
    accountStatus?: string | undefined;
    isMentorAccount?: boolean;

    constructor(data?: ITeacherAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teacherId = _data["teacherId"];
            this.teacher = _data["teacher"] ? Teacher.fromJS(_data["teacher"]) : <any>undefined;
            this.accountName = _data["accountName"];
            this.password = _data["password"];
            this.accountStatus = _data["accountStatus"];
            this.isMentorAccount = _data["isMentorAccount"];
        }
    }

    static fromJS(data: any): TeacherAccount {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teacherId"] = this.teacherId;
        data["teacher"] = this.teacher ? this.teacher.toJSON() : <any>undefined;
        data["accountName"] = this.accountName;
        data["password"] = this.password;
        data["accountStatus"] = this.accountStatus;
        data["isMentorAccount"] = this.isMentorAccount;
        return data; 
    }
}

export interface ITeacherAccount {
    id?: number;
    teacherId?: number;
    teacher?: Teacher;
    accountName?: string | undefined;
    password?: string | undefined;
    accountStatus?: string | undefined;
    isMentorAccount?: boolean;
}

export class ClassRequestBody implements IClassRequestBody {
    id!: number;
    classNumber!: string;
    majorId!: number;
    teacherId!: number;

    constructor(data?: IClassRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.classNumber = _data["classNumber"];
            this.majorId = _data["majorId"];
            this.teacherId = _data["teacherId"];
        }
    }

    static fromJS(data: any): ClassRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new ClassRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classNumber"] = this.classNumber;
        data["majorId"] = this.majorId;
        data["teacherId"] = this.teacherId;
        return data; 
    }
}

export interface IClassRequestBody {
    id: number;
    classNumber: string;
    majorId: number;
    teacherId: number;
}

export class Class implements IClass {
    id?: number;
    classNumber?: string | undefined;
    majorId?: number;
    major?: Major;
    teacherId?: number;
    mentor?: Teacher;

    constructor(data?: IClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.classNumber = _data["classNumber"];
            this.majorId = _data["majorId"];
            this.major = _data["major"] ? Major.fromJS(_data["major"]) : <any>undefined;
            this.teacherId = _data["teacherId"];
            this.mentor = _data["mentor"] ? Teacher.fromJS(_data["mentor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Class {
        data = typeof data === 'object' ? data : {};
        let result = new Class();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["classNumber"] = this.classNumber;
        data["majorId"] = this.majorId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["teacherId"] = this.teacherId;
        data["mentor"] = this.mentor ? this.mentor.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IClass {
    id?: number;
    classNumber?: string | undefined;
    majorId?: number;
    major?: Major;
    teacherId?: number;
    mentor?: Teacher;
}

export class ClassInfoRequestBody implements IClassInfoRequestBody {
    classNumber?: string | undefined;
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;

    constructor(data?: IClassInfoRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classNumber = _data["classNumber"];
            this.department = _data["department"];
            this.grade = _data["grade"];
            this.majorName = _data["majorName"];
        }
    }

    static fromJS(data: any): ClassInfoRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new ClassInfoRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classNumber"] = this.classNumber;
        data["department"] = this.department;
        data["grade"] = this.grade;
        data["majorName"] = this.majorName;
        return data; 
    }
}

export interface IClassInfoRequestBody {
    classNumber?: string | undefined;
    department?: string | undefined;
    grade?: string | undefined;
    majorName?: string | undefined;
}

export class StudentRequestBody implements IStudentRequestBody {
    id!: number;
    name!: string;
    sex!: string;
    identityCardNumber!: string;
    studentNumber!: string;
    studentStatus?: string | undefined;
    homeAddress!: string;
    phoneNumber!: string;
    portrait?: string | undefined;
    majorId!: number;
    apartment?: string | undefined;
    chamber?: string | undefined;
    bed?: string | undefined;
    classId!: number;

    constructor(data?: IStudentRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sex = _data["sex"];
            this.identityCardNumber = _data["identityCardNumber"];
            this.studentNumber = _data["studentNumber"];
            this.studentStatus = _data["studentStatus"];
            this.homeAddress = _data["homeAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.portrait = _data["portrait"];
            this.majorId = _data["majorId"];
            this.apartment = _data["apartment"];
            this.chamber = _data["chamber"];
            this.bed = _data["bed"];
            this.classId = _data["classId"];
        }
    }

    static fromJS(data: any): StudentRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new StudentRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sex"] = this.sex;
        data["identityCardNumber"] = this.identityCardNumber;
        data["studentNumber"] = this.studentNumber;
        data["studentStatus"] = this.studentStatus;
        data["homeAddress"] = this.homeAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["portrait"] = this.portrait;
        data["majorId"] = this.majorId;
        data["apartment"] = this.apartment;
        data["chamber"] = this.chamber;
        data["bed"] = this.bed;
        data["classId"] = this.classId;
        return data; 
    }
}

export interface IStudentRequestBody {
    id: number;
    name: string;
    sex: string;
    identityCardNumber: string;
    studentNumber: string;
    studentStatus?: string | undefined;
    homeAddress: string;
    phoneNumber: string;
    portrait?: string | undefined;
    majorId: number;
    apartment?: string | undefined;
    chamber?: string | undefined;
    bed?: string | undefined;
    classId: number;
}

export class Student implements IStudent {
    id?: number;
    name?: string | undefined;
    sex?: string | undefined;
    identityCardNumber?: string | undefined;
    studentNumber?: string | undefined;
    studentStatus?: string | undefined;
    homeAddress?: string | undefined;
    phoneNumber?: string | undefined;
    portrait?: string | undefined;
    majorId?: number;
    major?: Major;
    apartment?: string | undefined;
    chamber?: string | undefined;
    bed?: string | undefined;
    classId?: number;
    class?: Class;

    constructor(data?: IStudent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sex = _data["sex"];
            this.identityCardNumber = _data["identityCardNumber"];
            this.studentNumber = _data["studentNumber"];
            this.studentStatus = _data["studentStatus"];
            this.homeAddress = _data["homeAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.portrait = _data["portrait"];
            this.majorId = _data["majorId"];
            this.major = _data["major"] ? Major.fromJS(_data["major"]) : <any>undefined;
            this.apartment = _data["apartment"];
            this.chamber = _data["chamber"];
            this.bed = _data["bed"];
            this.classId = _data["classId"];
            this.class = _data["class"] ? Class.fromJS(_data["class"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Student {
        data = typeof data === 'object' ? data : {};
        let result = new Student();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sex"] = this.sex;
        data["identityCardNumber"] = this.identityCardNumber;
        data["studentNumber"] = this.studentNumber;
        data["studentStatus"] = this.studentStatus;
        data["homeAddress"] = this.homeAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["portrait"] = this.portrait;
        data["majorId"] = this.majorId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["apartment"] = this.apartment;
        data["chamber"] = this.chamber;
        data["bed"] = this.bed;
        data["classId"] = this.classId;
        data["class"] = this.class ? this.class.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStudent {
    id?: number;
    name?: string | undefined;
    sex?: string | undefined;
    identityCardNumber?: string | undefined;
    studentNumber?: string | undefined;
    studentStatus?: string | undefined;
    homeAddress?: string | undefined;
    phoneNumber?: string | undefined;
    portrait?: string | undefined;
    majorId?: number;
    major?: Major;
    apartment?: string | undefined;
    chamber?: string | undefined;
    bed?: string | undefined;
    classId?: number;
    class?: Class;
}

export class EnrollRequestBody implements IEnrollRequestBody {
    id!: number;
    name!: string;
    sex!: string;
    identityCardNumber!: string;
    homeAddress!: string;
    phoneNumber!: string;
    portrait?: string | undefined;
    majorId!: number;
    requestResult?: string | undefined;

    constructor(data?: IEnrollRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sex = _data["sex"];
            this.identityCardNumber = _data["identityCardNumber"];
            this.homeAddress = _data["homeAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.portrait = _data["portrait"];
            this.majorId = _data["majorId"];
            this.requestResult = _data["requestResult"];
        }
    }

    static fromJS(data: any): EnrollRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sex"] = this.sex;
        data["identityCardNumber"] = this.identityCardNumber;
        data["homeAddress"] = this.homeAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["portrait"] = this.portrait;
        data["majorId"] = this.majorId;
        data["requestResult"] = this.requestResult;
        return data; 
    }
}

export interface IEnrollRequestBody {
    id: number;
    name: string;
    sex: string;
    identityCardNumber: string;
    homeAddress: string;
    phoneNumber: string;
    portrait?: string | undefined;
    majorId: number;
    requestResult?: string | undefined;
}

export class Enroll implements IEnroll {
    id?: number;
    name?: string | undefined;
    sex?: string | undefined;
    identityCardNumber?: string | undefined;
    homeAddress?: string | undefined;
    phoneNumber?: string | undefined;
    portrait?: string | undefined;
    majorId?: number;
    major?: Major;
    requestResult?: string | undefined;

    constructor(data?: IEnroll) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sex = _data["sex"];
            this.identityCardNumber = _data["identityCardNumber"];
            this.homeAddress = _data["homeAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.portrait = _data["portrait"];
            this.majorId = _data["majorId"];
            this.major = _data["major"] ? Major.fromJS(_data["major"]) : <any>undefined;
            this.requestResult = _data["requestResult"];
        }
    }

    static fromJS(data: any): Enroll {
        data = typeof data === 'object' ? data : {};
        let result = new Enroll();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sex"] = this.sex;
        data["identityCardNumber"] = this.identityCardNumber;
        data["homeAddress"] = this.homeAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["portrait"] = this.portrait;
        data["majorId"] = this.majorId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["requestResult"] = this.requestResult;
        return data; 
    }
}

export interface IEnroll {
    id?: number;
    name?: string | undefined;
    sex?: string | undefined;
    identityCardNumber?: string | undefined;
    homeAddress?: string | undefined;
    phoneNumber?: string | undefined;
    portrait?: string | undefined;
    majorId?: number;
    major?: Major;
    requestResult?: string | undefined;
}

export class CourseResponsibleByTeacherRequestBody implements ICourseResponsibleByTeacherRequestBody {
    id!: number;
    teacherId!: number;
    courseId!: number;
    classId?: number | undefined;
    semester!: string;

    constructor(data?: ICourseResponsibleByTeacherRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teacherId = _data["teacherId"];
            this.courseId = _data["courseId"];
            this.classId = _data["classId"];
            this.semester = _data["semester"];
        }
    }

    static fromJS(data: any): CourseResponsibleByTeacherRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new CourseResponsibleByTeacherRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teacherId"] = this.teacherId;
        data["courseId"] = this.courseId;
        data["classId"] = this.classId;
        data["semester"] = this.semester;
        return data; 
    }
}

export interface ICourseResponsibleByTeacherRequestBody {
    id: number;
    teacherId: number;
    courseId: number;
    classId?: number | undefined;
    semester: string;
}

export class CourseResponsibleByTeacher implements ICourseResponsibleByTeacher {
    id?: number;
    teacherId?: number;
    teacher?: Teacher;
    courseId?: number;
    course?: Course;
    classId?: number | undefined;
    class?: Class;
    semester?: string | undefined;

    constructor(data?: ICourseResponsibleByTeacher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teacherId = _data["teacherId"];
            this.teacher = _data["teacher"] ? Teacher.fromJS(_data["teacher"]) : <any>undefined;
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.classId = _data["classId"];
            this.class = _data["class"] ? Class.fromJS(_data["class"]) : <any>undefined;
            this.semester = _data["semester"];
        }
    }

    static fromJS(data: any): CourseResponsibleByTeacher {
        data = typeof data === 'object' ? data : {};
        let result = new CourseResponsibleByTeacher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teacherId"] = this.teacherId;
        data["teacher"] = this.teacher ? this.teacher.toJSON() : <any>undefined;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["classId"] = this.classId;
        data["class"] = this.class ? this.class.toJSON() : <any>undefined;
        data["semester"] = this.semester;
        return data; 
    }
}

export interface ICourseResponsibleByTeacher {
    id?: number;
    teacherId?: number;
    teacher?: Teacher;
    courseId?: number;
    course?: Course;
    classId?: number | undefined;
    class?: Class;
    semester?: string | undefined;
}

export class CourseScheduleRequestBody implements ICourseScheduleRequestBody {
    id!: number;
    courseResponsibleByTeacherId!: number;
    scheduledWeekday!: string;
    scheduledTime!: string;

    constructor(data?: ICourseScheduleRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
            this.scheduledWeekday = _data["scheduledWeekday"];
            this.scheduledTime = _data["scheduledTime"];
        }
    }

    static fromJS(data: any): CourseScheduleRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new CourseScheduleRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        data["scheduledWeekday"] = this.scheduledWeekday;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface ICourseScheduleRequestBody {
    id: number;
    courseResponsibleByTeacherId: number;
    scheduledWeekday: string;
    scheduledTime: string;
}

export class CourseSchedule implements ICourseSchedule {
    id?: number;
    courseResponsibleByTeacherId?: number;
    teacherCourseInfo?: CourseResponsibleByTeacher;
    scheduledWeekday?: string | undefined;
    scheduledTime?: string | undefined;

    constructor(data?: ICourseSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
            this.teacherCourseInfo = _data["teacherCourseInfo"] ? CourseResponsibleByTeacher.fromJS(_data["teacherCourseInfo"]) : <any>undefined;
            this.scheduledWeekday = _data["scheduledWeekday"];
            this.scheduledTime = _data["scheduledTime"];
        }
    }

    static fromJS(data: any): CourseSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        data["teacherCourseInfo"] = this.teacherCourseInfo ? this.teacherCourseInfo.toJSON() : <any>undefined;
        data["scheduledWeekday"] = this.scheduledWeekday;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface ICourseSchedule {
    id?: number;
    courseResponsibleByTeacherId?: number;
    teacherCourseInfo?: CourseResponsibleByTeacher;
    scheduledWeekday?: string | undefined;
    scheduledTime?: string | undefined;
}

export class CourseSelectionRequestBody implements ICourseSelectionRequestBody {
    id!: number;
    studentId!: number;
    courseResponsibleByTeacherId!: number;

    constructor(data?: ICourseSelectionRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
        }
    }

    static fromJS(data: any): CourseSelectionRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSelectionRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        return data; 
    }
}

export interface ICourseSelectionRequestBody {
    id: number;
    studentId: number;
    courseResponsibleByTeacherId: number;
}

export class CourseSelection implements ICourseSelection {
    id?: number;
    studentId?: number;
    student?: Student;
    courseResponsibleByTeacherId?: number;
    teacherCourseInfo?: CourseResponsibleByTeacher;

    constructor(data?: ICourseSelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
            this.teacherCourseInfo = _data["teacherCourseInfo"] ? CourseResponsibleByTeacher.fromJS(_data["teacherCourseInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSelection {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSelection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        data["teacherCourseInfo"] = this.teacherCourseInfo ? this.teacherCourseInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICourseSelection {
    id?: number;
    studentId?: number;
    student?: Student;
    courseResponsibleByTeacherId?: number;
    teacherCourseInfo?: CourseResponsibleByTeacher;
}

export class ExaminationRequestBody implements IExaminationRequestBody {
    id!: number;
    studentId!: number;
    examSubject!: string;
    examDate!: Date;
    courseResponsibleByTeacherId?: number | undefined;
    perormance?: string | undefined;
    score?: number | undefined;

    constructor(data?: IExaminationRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.examSubject = _data["examSubject"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
            this.perormance = _data["perormance"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ExaminationRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new ExaminationRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["examSubject"] = this.examSubject;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        data["perormance"] = this.perormance;
        data["score"] = this.score;
        return data; 
    }
}

export interface IExaminationRequestBody {
    id: number;
    studentId: number;
    examSubject: string;
    examDate: Date;
    courseResponsibleByTeacherId?: number | undefined;
    perormance?: string | undefined;
    score?: number | undefined;
}

export class Examination implements IExamination {
    id?: number;
    studentId?: number;
    student?: Student;
    examSubject?: string | undefined;
    examDate?: Date;
    courseResponsibleByTeacherId?: number | undefined;
    teacherCourseInfo?: CourseResponsibleByTeacher;
    perormance?: string | undefined;
    score?: number | undefined;

    constructor(data?: IExamination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.examSubject = _data["examSubject"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.courseResponsibleByTeacherId = _data["courseResponsibleByTeacherId"];
            this.teacherCourseInfo = _data["teacherCourseInfo"] ? CourseResponsibleByTeacher.fromJS(_data["teacherCourseInfo"]) : <any>undefined;
            this.perormance = _data["perormance"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): Examination {
        data = typeof data === 'object' ? data : {};
        let result = new Examination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["examSubject"] = this.examSubject;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["courseResponsibleByTeacherId"] = this.courseResponsibleByTeacherId;
        data["teacherCourseInfo"] = this.teacherCourseInfo ? this.teacherCourseInfo.toJSON() : <any>undefined;
        data["perormance"] = this.perormance;
        data["score"] = this.score;
        return data; 
    }
}

export interface IExamination {
    id?: number;
    studentId?: number;
    student?: Student;
    examSubject?: string | undefined;
    examDate?: Date;
    courseResponsibleByTeacherId?: number | undefined;
    teacherCourseInfo?: CourseResponsibleByTeacher;
    perormance?: string | undefined;
    score?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}